name: Deploy to EKS

on:
  workflow_call:
    inputs:
      ecr_repo:
        required: true
        type: string
      eks_cluster_name:
        required: true
        type: string
      deployment_mode:
        required: false
        type: string
        default: 'singlefile'
      deployment_file:
        required: false
        type: string
        default: './deployment.template.yaml'
      deployment_files:
        required: false
        type: string
        default: ''
      continue_on_validation_error:
        required: false
        type: boolean
        default: false
      delete_old_images:
        required: false
        type: boolean
        default: false

    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      AWS_REGION:
        required: true

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      region: ${{ steps.export-region.outputs.region }}
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --name ${{ inputs.eks_cluster_name }} \
            --region ${{ secrets.AWS_REGION }}

      - name: Export Region
        id: export-region
        run: echo "region=${{ secrets.AWS_REGION }}" >> $GITHUB_OUTPUT

  resolve-image:
    runs-on: ubuntu-latest
    needs: setup
    outputs:
      image_tag: ${{ steps.get-tag.outputs.image_tag }}
    steps:
      - name: Get latest ECR image tag
        id: get-tag
        run: |
          IMAGE_TAG=$(aws ecr describe-images \
            --repository-name $(basename ${{ inputs.ecr_repo }}) \
            --region ${{ secrets.AWS_REGION }} \
            --query 'sort_by(imageDetails,& imagePushedAt)[-1].imageTags[0]' \
            --output text)
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

  generate-manifests:
    runs-on: ubuntu-latest
    needs: [setup, resolve-image]
    outputs:
      manifest_dir: ${{ steps.set-output.outputs.dir }}
    steps:
      - name: Substitute {{IMAGE}} placeholder
        id: set-output
        run: |
          IMAGE="${{ inputs.ecr_repo }}:${{ needs.resolve-image.outputs.image_tag }}"
          echo "Using image: $IMAGE"

          if [ "${{ inputs.deployment_mode }}" = "singlefile" ]; then
            sed "s|{{IMAGE}}|$IMAGE|g" ${{ inputs.deployment_file }} > final-deployment.yaml
            echo "Processed single file."
            echo "dir=." >> $GITHUB_OUTPUT

          elif [ "${{ inputs.deployment_mode }}" = "filenames" ]; then
            IFS=',' read -ra FILES <<< "${{ inputs.deployment_files }}"
            mkdir -p final-files
            for file in "${FILES[@]}"; do
              sed "s|{{IMAGE}}|$IMAGE|g" "$file" > "final-files/$(basename "$file")"
            done
            echo "dir=final-files" >> $GITHUB_OUTPUT

          elif [ "${{ inputs.deployment_mode }}" = "recursive" ]; then
            mkdir -p final-recursive
            find ./k8s -type f -name '*.yaml' | while read -r file; do
              relpath=$(realpath --relative-to=. "$file")
              mkdir -p "final-recursive/$(dirname "$relpath")"
              sed "s|{{IMAGE}}|$IMAGE|g" "$file" > "final-recursive/$relpath"
            done
            echo "dir=final-recursive" >> $GITHUB_OUTPUT

  deploy:
    runs-on: ubuntu-latest
    needs: generate-manifests
    steps:
      - name: Apply Manifests to EKS
        run: |
          echo "Applying manifests from ${{ needs.generate-manifests.outputs.manifest_dir }}"
          kubectl apply -R -f ${{ needs.generate-manifests.outputs.manifest_dir }}

  validate:
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    continue-on-error: ${{ inputs.continue_on_validation_error }}
    steps:
      - name: Validate rollout is successful
        run: |
          MAX_RETRIES=5
          RETRY_INTERVAL=30
          RETRIES=0
          DEPLOYMENT_NAME="my-app"
          NAMESPACE="default"

          while [ $RETRIES -lt $MAX_RETRIES ]; do
            STATUS=$(kubectl rollout status deployment/$DEPLOYMENT_NAME -n $NAMESPACE --timeout=10s || true)
            echo "$STATUS"

            if [[ "$STATUS" == *"successfully rolled out"* ]]; then
              echo "Deployment is healthy."
              exit 0
            else
              sleep $RETRY_INTERVAL
              RETRIES=$((RETRIES + 1))
            fi
          done

          echo "Deployment failed after $MAX_RETRIES attempts."
          exit 1

  cleanup-ecr:
    runs-on: ubuntu-latest
    needs: setup
    if: ${{ inputs.delete_old_images == true }}
    steps:
      - name: Prune old and untagged ECR images
        run: |
          REPO_NAME=$(basename ${{ inputs.ecr_repo }})
          REGION=${{ secrets.AWS_REGION }}
          IMAGES_TO_KEEP=5

          TAGGED_IMAGE_DETAILS=$(aws ecr describe-images \
            --repository-name "$REPO_NAME" \
            --region "$REGION" \
            --query 'sort_by(imageDetails,& imagePushedAt)[?imageTags!=null]' \
            --output json)

          TAGGED_IMAGE_COUNT=$(echo "$TAGGED_IMAGE_DETAILS" | jq length)

          if [ "$TAGGED_IMAGE_COUNT" -le "$IMAGES_TO_KEEP" ]; then
            echo "Only $TAGGED_IMAGE_COUNT tagged image(s) found. Skipping prune."
          else
            DIGESTS_TO_DELETE=$(echo "$TAGGED_IMAGE_DETAILS" | jq -r ".[0:($TAGGED_IMAGE_COUNT - $IMAGES_TO_KEEP)] | .[].imageDigest")
            for DIGEST in $DIGESTS_TO_DELETE; do
              aws ecr batch-delete-image \
                --repository-name "$REPO_NAME" \
                --region "$REGION" \
                --image-ids imageDigest=$DIGEST
            done
          fi

          UNTAGGED_IMAGES=$(aws ecr list-images \
            --repository-name "$REPO_NAME" \
            --region "$REGION" \
            --filter tagStatus=UNTAGGED \
            --query 'imageIds[*]' \
            --output json)

          if [ "$(echo "$UNTAGGED_IMAGES" | jq length)" -gt 0 ]; then
            aws ecr batch-delete-image \
              --repository-name "$REPO_NAME" \
              --region "$REGION" \
              --image-ids "$UNTAGGED_IMAGES"
          fi

          echo "ECR cleanup complete."
